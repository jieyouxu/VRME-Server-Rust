//! Settings for the application server.
//!
//! Supports parsing tiered settings format and overriding from environment variables prefixed
//! with `APP_` for settings keys of the same name.
//!
//! Currently support format:
//!
//! - TOML
//! - YAML
//! - JSON

use config::{Config, ConfigError, Environment, File};
use derive_more::Display;
use log::{debug, error, info, warn};
use serde::Deserialize;
use std::env;
use std::net::IpAddr;

/// Errors encountered when trying to determine the settings for the
/// application.
#[derive(Debug, Display)]
pub enum SettingsError {
	/// Failed to find settings file.
	#[display(fmt = "settings file not found at: `{}`", "_0")]
	NotFound(String),
	/// Failed to read settings file due to IO errors.
	#[display(fmt = "failed to read settings due to IO error: `{:?}`", "_0")]
	IOError(std::io::Error),
	/// Failed to parse settings file. Contains illegal syntax.
	#[display(fmt = "invalid syntax: `{}`", "_0")]
	InvalidSyntax(String),
	/// Other settings errors.
	#[display(fmt = "settings error: `{:?}`", "_0")]
	Other(Box<dyn std::error::Error>),
}

impl std::error::Error for SettingsError {}

impl std::convert::From<ConfigError> for SettingsError {
	fn from(error: ConfigError) -> Self {
		match error {
			ConfigError::NotFound(s) => Self::NotFound(s),
			e => Self::Other(Box::new(e)),
		}
	}
}

/// The settings for the application.
#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
	pub database: DatabaseSettings,
	pub logging: LoggingSettings,
	pub server: ServerSettings,
	pub auth: AuthSettings,
	pub rate_limiting: RateLimitingSettings,
	/// Optional TLS support. Omitting the `tls` section in the configuration file will only run the
	/// non-TLS server at the desired port specified in `server.port`.
	pub tls: Option<TlsSettings>,
}

/// Database settings.
#[derive(Debug, Deserialize, Clone)]
pub struct DatabaseSettings {
	pub username: String,
	pub password: String,
	pub hostname: IpAddr,
	pub port: u16,
	pub database_name: String,
	/// Max number of database connections to maintain in a connection pool.
	#[serde(default = "default_pool_size")]
	pub pool_size: usize,
}

fn default_pool_size() -> usize {
	32
}

/// Logging settings.
#[derive(Debug, Deserialize, Clone)]
pub struct LoggingSettings {
	pub level: LoggingLevel,
}

/// Logging levels. The most specific is `LoggingLevel::Trace`, and the least
/// specific is `LoggingLevel::Error`.
///
/// # Logging in Production
///
/// **Production** environments should *not* use debug levels more specific
/// than `LoggingLevel::Info` as `LoggingLevel::Trace` and
/// `LoggingLevel::Debug` is permitted to log sensitive information such as
/// passwords and IPs to `stdout` or `stderr`.
#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "UPPERCASE")]
pub enum LoggingLevel {
	Trace,
	Debug,
	Info,
	Warn,
	Error,
}

/// Server settings.
#[derive(Debug, Deserialize, Clone)]
pub struct ServerSettings {
	/// Which IP address the application server should bind to.
	pub hostname: IpAddr,
	/// Which port the application server should listen on.
	pub port: u16,
	/// Max JSON payload size in bytes.
	#[serde(default = "default_json_size_limit")]
	pub json_size_limit: usize,
}

fn default_json_size_limit() -> usize {
	4096
}

/// Authentication settings.
#[derive(Debug, Deserialize, Clone)]
pub struct AuthSettings {
	/// Length of the `auth_token` in bytes.
	#[serde(default = "default_auth_token_length")]
	pub auth_token_length: u32,

	/// Validity duration of `auth_token`s in hours. When there does not exist a `auth_token`
	/// associated with the user of uuid `uuid`, the user must first login at `POST /login`. Upon
	/// successful login, the client is able to use the `uuid` + `auth_token` combination to
	/// authenticate themselves for accessing protected API endpoints as long the `auth_token` is
	/// has not **expired** yet.
	///
	/// An `auth_token` is said to have **expired** when the last time an user used the `auth_token`
	/// to access a protected endpoint was more than `auth_token_validity_duration` hours ago
	/// compared to the current time.
	///
	/// However, before the `auth_token` expires, if a user uses the `auth_token` to authenticate
	/// for a protected endpoint successfully, then the `last_used` time for the `auth_token`
	/// will be updated so the `auth_token` will restart its validity duration. In essence, if a
	/// user authenticates more often with an `auth_token` then they don't need to login, unless
	/// their `auth_token` was explicitly removed.
	#[serde(default = "default_auth_token_validity_duration")]
	pub auth_token_validity_duration: u32,
}

/// Default `auth_token` length in bytes. The `auth_token` should be strong enough (partly by
/// being long enough, and also from being generated by cryptographically-strong CSPRNG that at
/// periodically samples from true random entropy sources.
fn default_auth_token_length() -> u32 {
	32
}

/// Default `auth_token` validity duration is 30 days.
fn default_auth_token_validity_duration() -> u32 {
	chrono::Duration::days(30).num_hours() as u32
}

/// Rate limiting settings.
#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitingSettings {
	/// How long (in seconds) before requests count is reset for each IP address.
	#[serde(default = "default_cooldown_duration")]
	pub cooldown_duration: u64,
	/// How many requests are permitted for each IP address in the duration.
	#[serde(default = "default_max_requests")]
	pub max_requests: usize,
}

/// Default cooldown duration is `60` seconds.
fn default_cooldown_duration() -> u64 {
	60
}

/// Default max requests per duration is clamped to `100`.
fn default_max_requests() -> usize {
	100
}

/// TLS settings.
#[derive(Debug, Deserialize, Clone)]
pub struct TlsSettings {
	/// Should the server enable TLS support and additionally listen on the given `port`?
	pub use_tls: bool,
	/// TLS port â€“ should be different from the non-TLS port.
	pub port: u16,
	/// Relative path to the certificate file.
	pub cert_path: String,
	/// Relative path to the key file.
	pub key_path: String,
}

// For the key `database.username`, the environment variable
// `APP_DATABASE__USERNAME` will override the value read from the various
// configuration files because environment variables have higher
// precedence.
pub const NESTED_SETTINGS_ENV_NAME_SEPARATOR: &str = "__";

impl Settings {
	/// Construct new settings.
	///
	/// # Settings Precedence
	///
	/// By default, the order that settings are overridden is (in order of
	/// increasing precedence):
	///
	/// 1. Settings file.
	///     1. Default settings file located at `config/default`.
	///     2. Based on `RUN_MODE` environment variable, we mix in:
	///         - `RUN_MODE=production`: `config/production`.
	///         - `RUN_MODE=development`: `config/development`.
	/// 2. Environment variables.
	/// 3. CLI command arguments (if any).
	pub fn new() -> Result<Self, SettingsError> {
		let mut cfg = Config::new();

		// We first mixin the configuration that is intended to be shared
		// regardless of `RUN_MODE`.
		cfg.merge(File::with_name("config/default"))?;

		info!("Read config from `config/default`");
		debug!("Provided config from `config/default`:\n {:#?}", &cfg);

		// Then, we add `RUN_MODE`-determined configuration. Defaults to
		// `development` mode, which takes configuration file at
		// `config/development`.
		if let Ok(run_mode) = env::var("RUN_MODE") {
			match &run_mode[..] {
				"development" => {
					cfg.merge(File::with_name("config/default").required(false))?;
					info!("Reading config from `config/development`");
					debug!("Provided config from `config/development`:\n {:#?}", &cfg);
				}
				"production" => {
					cfg.merge(File::with_name("config/production").required(false))?;
					info!("Reading config from `config/production`");
					debug!("Provided config from `config/production`:\n {:#?}", &cfg);
				}
				other => {
					warn!(
						"Invalid run mode: \"{}\" given, expected one of \"development\" or \
					 	\"production\"",
						other
					);
					warn!("Only using configuration from `config/default`!");
				}
			};
		}

		// Then, we mixin environment variables which overrides the keys with a
		// prefix of `APP`.
		//
		// # Example
		//
		// For the key `database.username`, the environment variable
		// `APP_DATABASE__USERNAME` will override the value read from the various
		// configuration files because environment variables have higher
		// precedence.
		cfg.merge(Environment::with_prefix("APP").separator(NESTED_SETTINGS_ENV_NAME_SEPARATOR))?;

		info!("Mixed in configuration from environment variables");

		match cfg.try_into() {
			Ok(validated_settings) => {
				info!("Settings are validated");
				debug!("Final settings:\n {:#?}", &validated_settings);
				Ok(validated_settings)
			}
			Err(e) => {
				error!("Settings could not be parsed!");
				error!("Error cause:\n {:#?}", &e);
				Err(SettingsError::InvalidSyntax(e.to_string()))
			}
		}
	}
}
