//! Handles user registration and account creation.
//!
//! We require that the client supply a *hashed* password from the client-side which shall be
//! generated by a cryptographically-strong hashing function such as `SHA-256` to avoid transferring
//! the plain-text password over the network which could be compromised.
//!
//! # Reference
//!
//! - [SHA-256](https://tools.ietf.org/html/rfc4634)

use crate::database::postgresql::ConnectionPool;
use crate::service_errors::ServiceError;
use crate::types::client_hashed_password::ClientHashedPassword;
use crate::types::hashed_password::HashedPassword;
use actix_web::Error;
use actix_web::{web, HttpResponse};
use deadpool_postgres::Client;
use log::debug;
use serde::{Deserialize, Serialize};
use serde_json::json;
use uuid::Uuid;

/// Required payload when a user wishes to register to create a new account.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RegistrationRequest {
	pub email: String,
	pub first_name: String,
	pub last_name: String,
	pub hashed_password: String,
}

/// POST endpoint handler for user registration.
///
/// # Endpoint
///
/// - **HTTP Verb**: `POST`
/// - **Payload Required**?: YES
///
/// # Required Headers
///
/// - Content type: `Content-Type: application/json`
/// - Content length: `Content-Length: <JSON_SIZE>` where `<JSON_SIZE>: u32`
///
/// # Required Payload
///
/// Payload format and required fields are specified by `RegistrationRequest`.
///
/// # Example Request
///
/// ```http
/// POST /register HTTP 1.1
/// Content-Type: application/json
/// Content-Length: 135
///
/// {
///     "email": "no-reply@example.com",
///     "first_name": "John",
///     "last_name": "Doe",
///     "hashed_password": "0123456789012345678901234567890123456789012"
/// }
/// ```
///
/// # Errors
///
/// Refer to the API endpoint documentation for possible error responses.
pub async fn handle_registration(
	request_info: web::Json<RegistrationRequest>,
	pool: web::Data<ConnectionPool>,
) -> Result<HttpResponse, Error> {
	debug!("Request:\n {:?}", &request_info);
	validate_request_payload(request_info.clone()).await?;

	// We first need to base64-decode the client password hash.
	let client_password_hash = ClientHashedPassword::new(&request_info.hashed_password)?;
	let client_password_hash = client_password_hash.decode().await?;

	// We then need to compute the `PasswordHashInfo` to store them into the database.
	let password_hash_info = HashedPassword::new(&client_password_hash).await?;

	let client = pool.get().await?;
	let (user_id, email) =
		create_account_if_not_exists(&client, &request_info, &password_hash_info).await?;

	Ok(make_success_response(&user_id, &email))
}

async fn validate_request_payload(payload: RegistrationRequest) -> Result<(), ServiceError> {
	let task = move || {
		validate_name_length(&payload.first_name, "first_name")?;
		validate_name_length(&payload.last_name, "last_name")?;
		validate_email(&payload.email)?;
		Ok::<(), ServiceError>(())
	};

	web::block(task).await.map_err(|e| e.into())
}

fn validate_name_length(name: &str, name_kind: &str) -> Result<(), ServiceError> {
	if name.is_empty() {
		Err(ServiceError::BadRequest(format!(
			"`{}` canot be empty",
			name_kind
		)))
	} else if name.len() > 100 {
		Err(ServiceError::BadRequest(format!(
			"`{}` is too long",
			name_kind
		)))
	} else {
		Ok(())
	}
}

// Only checks that the email has a minimum length of 3 characters and must include `@` character.
fn validate_email(email: &str) -> Result<(), ServiceError> {
	if email.len() < 3 {
		Err(ServiceError::BadRequest(
			"Invalid email address: too short".to_string(),
		))
	} else if !email.contains('@') {
		Err(ServiceError::BadRequest(
			"Invalid email address".to_string(),
		))
	} else {
		Ok(())
	}
}

const CREATE_USER_QUERY: &str = r#"
    INSERT INTO accounts
    (
        user_id,
        email,
        first_name,
        last_name,
        iteration_count,
        salt,
        password_hash,
        created_at
    )
    VALUES
    (
        $1::UUID,           --user_id
        $2::VARCHAR(355),   --email
        $3::VARCHAR(100),   --first_name
        $4::VARCHAR(100),   --last_name
        $5::INT,            --iteration_count
        $6::BYTEA,          --salt,
        $7::BYTEA,          --password_hash,
        $8::DATE            --created_at
    )
    ON CONFLICT DO NOTHING
    RETURNING user_id, email;
"#;

async fn create_account_if_not_exists(
	client: &Client,
	request_info: &RegistrationRequest,
	hashed_password: &HashedPassword,
) -> Result<(Uuid, String), ServiceError> {
	let statement = client.prepare(CREATE_USER_QUERY).await.unwrap();
	let uuid = Uuid::new_v4();
	let date = chrono::Utc::today().naive_utc();
	let iteration_count = hashed_password.iteration_count as i32;

	let rows = client
		.query(
			&statement,
			&[
				&uuid,
				&request_info.email,
				&request_info.first_name,
				&request_info.last_name,
				&iteration_count,
				&hashed_password.salt,
				&hashed_password.hash,
				&date,
			],
		)
		.await?;

	if rows.is_empty() {
		// We did not successfully create a new account with the provided email address. An account
		// with the given email address already exists.
		Err(ServiceError::Conflict(format!(
			"An account with the given email address {} already exists",
			&request_info.email
		)))
	} else {
		// We successfully created a new account with the given email address.
		let (user_id, email) = (rows[0].get(0), rows[0].get(1));
		Ok((user_id, email))
	}
}

fn make_success_response(user_id: &Uuid, email: &str) -> HttpResponse {
	let message = json!({
		"message": format!("Account with email {} successfully created", email),
		"data": {
			"user_id": user_id,
			"email": email
		}
	});

	HttpResponse::Created().json(message)
}
