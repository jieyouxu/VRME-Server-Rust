//! Handles user registration and account creation.
//!
//! We require that the client supply a *hashed* password from the client-side which shall be
//! generated by a cryptographically-strong hashing function such as `SHA-256` to avoid transferring
//! the plain-text password over the network which could be compromised.
//!
//! # Reference
//!
//! - [SHA-256](https://tools.ietf.org/html/rfc4634)

use crate::database::ConnectionPool;
use crate::service_errors::ServiceError;
use crate::types::client_hashed_password::ClientHashedPassword;
use crate::types::hashed_password::HashedPassword;
use actix_web::{web, HttpResponse, ResponseError};
use deadpool_postgres::Client;
use log::debug;
use serde::{Deserialize, Serialize};
use serde_json::json;
use uuid::Uuid;

/// Required payload when a user wishes to register to create a new account.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RegistrationRequest {
	pub email: String,
	pub first_name: String,
	pub last_name: String,
	pub hashed_password: String,
}

/// POST endpoint handler for user registration.
///
/// # Endpoint
///
/// - **HTTP Verb**: `POST`
/// - **Payload Required**?: YES
///
/// # Required Headers
///
/// - Content type: `Content-Type: application/json`
/// - Content length: `Content-Length: <JSON_SIZE>` where `<JSON_SIZE>: u32`
///
/// # Required Payload
///
/// Payload format and required fields are specified by `RegistrationRequest`.
///
/// # Example Request
///
/// ```http
/// POST /register HTTP 1.1
/// Content-Type: application/json
/// Content-Length: 135
///
/// {
///     "email": "no-reply@example.com",
///     "first_name": "John",
///     "last_name": "Doe",
///     "hashed_password": "0123456789012345678901234567890123456789012"
/// }
/// ```
///
/// # Errors
///
/// Refer to the API endpoint documentation for possible error responses.
pub async fn handle_registration(
	request_info: web::Json<RegistrationRequest>,
	pool: web::Data<ConnectionPool>,
) -> HttpResponse {
	debug!("Request:\n {:?}", &request_info);

	if let Err(e) = validate_request_payload(request_info.clone()).await {
		debug!("{}", &e);
		return e.error_response();
	}

	// We first need to base64-decode the client password hash.
	let client_password_hash =
		match ClientHashedPassword::new(&request_info.hashed_password) {
			Ok(hash) => hash,
			Err(e) => return e.error_response(),
		};

	let client_password_hash = match client_password_hash.decode().await {
		Ok(hash) => hash,
		Err(e) => return e.error_response(),
	};

	// We then need to compute the `PasswordHashInfo` to store them into the database.
	let password_hash_info =
		match HashedPassword::new(&client_password_hash).await {
			Ok(info) => info,
			Err(e) => {
				debug!("{}", &e);
				return ServiceError::InternalServerError(e.to_string())
					.error_response();
			}
		};

	let client = match pool.get().await {
		Ok(client) => client,
		Err(e) => {
			debug!("{}", &e);
			return ServiceError::InternalServerError(e.to_string())
				.error_response();
		}
	};

	let (user_id, email) = match create_account_if_not_exists(
		&client,
		&request_info,
		&password_hash_info,
	)
	.await
	{
		Ok((user_id, email)) => (user_id, email),
		Err(e) => {
			debug!("{}", &e);
			return e.error_response();
		}
	};

	make_success_response(&user_id, &email)
}

async fn validate_request_payload(
	payload: RegistrationRequest,
) -> Result<(), ServiceError> {
	web::block(move || {
		validate_name_length(&payload.first_name, "first_name")?;
		validate_name_length(&payload.last_name, "last_name")?;
		validate_email(&payload.email)?;
		Ok::<(), ServiceError>(())
	})
	.await
	.map_err(|e| {
		if let actix_web::error::BlockingError::Error(err) = e {
			err
		} else {
			ServiceError::InternalServerError(e.to_string())
		}
	})
}

fn validate_name_length(
	name: &str,
	name_kind: &str,
) -> Result<(), ServiceError> {
	if name.is_empty() {
		return Err(ServiceError::BadRequest(format!(
			"`{}` canot be empty",
			name_kind
		)));
	}

	if name.len() > 100 {
		return Err(ServiceError::BadRequest(format!(
			"`{}` is too long",
			name_kind
		)));
	}

	Ok(())
}

// Only checks that the email has a minimum length of 3 characters and must include `@` character.
fn validate_email(email: &str) -> Result<(), ServiceError> {
	if email.len() < 3 {
		return Err(ServiceError::BadRequest(
			"Invalid email address: too short".to_string(),
		));
	}

	if !email.contains('@') {
		return Err(ServiceError::BadRequest(
			"Invalid email address".to_string(),
		));
	}

	Ok(())
}

const CREATE_USER_QUERY: &str = r#"
    INSERT INTO accounts
    (
        user_id,
        email,
        first_name,
        last_name,
        iteration_count,
        salt,
        password_hash,
        created_at
    )
    VALUES
    (
        $1::UUID,           --user_id
        $2::VARCHAR(355),   --email
        $3::VARCHAR(100),   --first_name
        $4::VARCHAR(100),   --last_name
        $5::INT,            --iteration_count
        $6::BYTEA,          --salt,
        $7::BYTEA,          --password_hash,
        $8::DATE            --created_at
    )
    ON CONFLICT DO NOTHING
    RETURNING user_id, email;
"#;

async fn create_account_if_not_exists(
	client: &Client,
	request_info: &RegistrationRequest,
	hashed_password: &HashedPassword,
) -> Result<(Uuid, String), ServiceError> {
	let statement = client.prepare(CREATE_USER_QUERY).await.unwrap();
	let uuid = Uuid::new_v4();
	let date = chrono::Utc::today().naive_utc();
	let iteration_count = hashed_password.iteration_count as i32;

	let rows = client
		.query(
			&statement,
			&[
				&uuid,
				&request_info.email,
				&request_info.first_name,
				&request_info.last_name,
				&iteration_count,
				&hashed_password.salt,
				&hashed_password.hash,
				&date,
			],
		)
		.await
		.map_err(|e| ServiceError::InternalServerError(e.to_string()))?;

	if rows.is_empty() {
		// We did not successfully create a new account with the provided email address. An account
		// with the given email address already exists.
		Err(ServiceError::Conflict(format!(
			"An account with the given email address {} already exists",
			&request_info.email
		)))
	} else {
		// We successfully created a new account with the given email address.
		let (user_id, email) = (rows[0].get(0), rows[0].get(1));
		Ok((user_id, email))
	}
}

fn make_success_response(user_id: &Uuid, email: &str) -> HttpResponse {
	let message = json!({
		"message": format!("Account with email {} successfully created", email),
		"data": {
			"user_id": user_id,
			"email": email
		}
	});

	HttpResponse::Created().json(message)
}
